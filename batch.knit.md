---
title: Correcting batch effects in single-cell RNA-seq data
author: 
- name: Aaron T. L. Lun
  affiliation: Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
- name: Michael D. Morgan
  affiliation: Wellcome Trust Sanger Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SA, United Kingdom
date: "2019-04-13"
vignette: >
  %\VignetteIndexEntry{05. Correcting batch effects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
output: 
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
bibliography: ref.bib
---



# Introduction

Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints.
However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality.
This results in systematic differences in the observed expression in cells from different batches, which we refer to as "batch effects".
Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.

Computational correction of these effects is critical for eliminating batch-to-batch variation, allowing data across multiple batches to be combined for valid downstream analysis.
However, existing methods such as `removeBatchEffect()` [@ritchie2015limma] assume that the composition of cell populations are either known or the same across batches.
This workflow describes the application of an alternative strategy for batch correction based on the detection of mutual nearest neighbours (MNNs) [@haghverdi2018batch].
The MNN approach does not rely on pre-defined or equal population compositions across batches, only requiring that a subset of the population be shared between batches.
We demonstrate its use on two human pancreas scRNA-seq datasets generated in separate studies.

# Processing the different datasets

## CEL-seq, GSE81076

### Loading in the data

This dataset was generated by @grun2016denovo using the CEL-seq protocol with unique molecular identifiers (UMIs) and ERCC spike-ins.
Count tables were obtained from the NCBI Gene Expression Omnibus using the accession number above.


```r
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
grun.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE81nnn/GSE81076/suppl/GSE81076%5FD2%5F3%5F7%5F10%5F17%2Etxt%2Egz"))
```

We first read the table into memory.


```r
gse81076.df <- read.table(grun.fname, sep='\t', 
    header=TRUE, stringsAsFactors=FALSE, row.names=1)
dim(gse81076.df)
```

```
## [1] 20148  1728
```

Unfortunately, the data and metadata are all mixed together in this file.
As a result, we need to manually extract the metadata from the column names.


```r
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse81076.df))
table(donor.names)
```

```
## donor.names
##    D101    D102  D10631     D17   D1713 D172444      D2      D3     D71 
##      96      96      96     288      96      96      96     480      96 
##     D72     D73     D74 
##      96      96      96
```

```r
plate.id <- sub("^D[0-9]+(.*)_.*", "\\1", colnames(gse81076.df))
table(plate.id)
```

```
## plate.id
##      All1 All2  en1  en2  en3  en4   ex TGFB 
##  864   96   96   96   96   96   96  192   96
```

Another irritating feature of this dataset is that gene symbols were supplied, rather than stable identifiers such as Ensembl.
We convert all row names to Ensembl identifiers, removing `NA` or duplicated entries (with the exception of spike-in transcripts). 


```r
gene.symb <- gsub("__chr.*$", "", rownames(gse81076.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)
```

```
## is.spike
## FALSE  TRUE 
## 20064    84
```

```r
library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse81076.df <- gse81076.df[keep,]
rownames(gse81076.df) <- gene.ids[keep]
summary(keep)
```

```
##    Mode   FALSE    TRUE 
## logical    2071   18077
```

We create a `SingleCellExperiment` object to store the counts and metadata together.
This reduces the risk of book-keeping errors in later steps of the analysis.
Note that we re-identify the spike-in rows, as the previous indices would have changed after the subsetting.


```r
library(SingleCellExperiment)
sce.gse81076 <- SingleCellExperiment(list(counts=as.matrix(gse81076.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse81076, "ERCC") <- grepl("^ERCC-", rownames(gse81076.df)) 
sce.gse81076  
```

```
## class: SingleCellExperiment 
## dim: 18077 1728 
## metadata(0):
## assays(1): counts
## rownames(18077): ENSG00000268895 ENSG00000121410 ... ENSG00000074755
##   ENSG00000036549
## rowData names(1): Symbol
## colnames(1728): D2ex_1 D2ex_2 ... D17TGFB_95 D17TGFB_96
## colData names(2): Donor Plate
## reducedDimNames(0):
## spikeNames(1): ERCC
```

### Quality control and normalization

We compute quality control (QC) metrics for each cell [@mccarthy2017scater] and identify cells with low library sizes, low numbers of expressed genes, or high ERCC content.


```r
library(scater)
sce.gse81076 <- calculateQCMetrics(sce.gse81076, compact=TRUE)
QC <- sce.gse81076$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

```
##   LowLib LowNgenes HighSpike
## 1     55       130       388
```

Cells with extreme values for these QC metrics are presumed to be of low quality and are removed.
A more thorough analysis would examine the distributions of these QC metrics beforehand, but we will skip that step for brevity here.


```r
discard <- low.lib | low.genes | high.spike
sce.gse81076 <- sce.gse81076[,!discard]
summary(discard)
```

```
##    Mode   FALSE    TRUE 
## logical    1292     436
```

We compute size factors for the endogenous genes using the deconvolution method [@lun2016pooling].
This is done with pre-clustering by `quickCluster()` to avoid pooling together very different cells.


```r
library(scran)
library(BiocSingular)
set.seed(1000) # for irlba. 
clusters <- quickCluster(sce.gse81076, use.ranks=FALSE, BSPARAM=IrlbaParam())
table(clusters)
```

```
## clusters
##   1   2   3   4   5   6   7 
## 118 101 266 299 154 241 113
```

```r
sce.gse81076 <- computeSumFactors(sce.gse81076, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse81076))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.00469 0.42318 0.78835 1.00000 1.29216 8.62289
```

We also compute size factors for the spike-in transcripts [@lun2017assessing].
Recall that we set `general.use=FALSE` to ensure that the spike-in size factors are only applied to the spike-in transcripts.


```r
sce.gse81076 <- computeSpikeFactors(sce.gse81076, general.use=FALSE)
summary(sizeFactors(sce.gse81076, "ERCC"))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.01042 0.57782 0.88699 1.00000 1.27765 7.43998
```

We then compute normalized log-expression values for use in downstream analyses.


```r
sce.gse81076 <- normalize(sce.gse81076)
```

### Identifying highly variable genes

We identify highly variable genes (HVGs) using `trendVar()` and `decomposeVar()`, using the variances of spike-in transcripts to model technical noise.
We set `block=` to ensure that uninteresting differences between plates or donors do not inflate the variance.
The small discrepancy in the fitted trend in Figure \@ref(fig:var-gse81076) is caused by the fact that the trend is fitted robustly to the block-wise variances of the spike-ins, 
while the variances shown are averaged across blocks and not robust to outliers.


```r
block <- paste0(sce.gse81076$Plate, "_", sce.gse81076$Donor)
fit <- trendVar(sce.gse81076, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse81076, fit)

plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse81076)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

<div class="figure">
<img src="batch_files/figure-html/var-gse81076-1.png" alt="Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)." width="100%" />
<p class="caption">(\#fig:var-gse81076)Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).</p>
</div>

We order genes by decreasing biological component, revealing some usual suspects such as insulin and glucagon.
We will be using this information later when performing feature selection prior to running `mnnCorrect()`.


```r
dec.gse81076 <- dec
dec.gse81076$Symbol <- rowData(sce.gse81076)$Symbol
dec.gse81076 <- dec.gse81076[order(dec.gse81076$bio, decreasing=TRUE),]
head(dec.gse81076)
```

```
## DataFrame with 6 rows and 7 columns
##                             mean            total              bio
##                        <numeric>        <numeric>        <numeric>
## ENSG00000254647 2.84354986788675 6.37223658453819 5.92885912197339
## ENSG00000129965 1.88950987335824 6.02281611785607 5.57524591788433
## ENSG00000115263 4.02102813554184 5.79923366454836 5.56593885619407
## ENSG00000118271 3.67285962325439 5.80023170033878 5.49885083587672
## ENSG00000115386 4.24317140825674 5.41270206612667 5.17694035036249
## ENSG00000164266 3.03649146616406 5.43074151343319 5.02327614710772
##                              tech   p.value       FDR      Symbol
##                         <numeric> <numeric> <numeric> <character>
## ENSG00000254647 0.443377462564809         0         0         INS
## ENSG00000129965 0.447570199971736         0         0    INS-IGF2
## ENSG00000115263  0.23329480835429         0         0         GCG
## ENSG00000118271 0.301380864462058         0         0         TTR
## ENSG00000115386 0.235761715764185         0         0       REG1A
## ENSG00000164266 0.407465366325469         0         0      SPINK1
```



## CEL-seq2, GSE85241

### Loading in the data

This dataset was generated by @muraro2016singlecell using the CEL-seq2 protocol with unique molecular identifiers (UMIs) and ERCC spike-ins.
Count tables were obtained from the NCBI Gene Expression Omnibus using the accession number above.


```r
muraro.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE85nnn/GSE85241/suppl",
    "GSE85241%5Fcellsystems%5Fdataset%5F4donors%5Fupdated%2Ecsv%2Egz"))
```

We first read the table into memory.


```r
gse85241.df <- read.table(muraro.fname, sep='\t', 
    header=TRUE, row.names=1, stringsAsFactors=FALSE)
dim(gse85241.df)
```

```
## [1] 19140  3072
```

We extract the metadata from the column names.


```r
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse85241.df))
table(donor.names)
```

```
## donor.names
## D28 D29 D30 D31 
## 768 768 768 768
```

```r
plate.id <- sub("^D[0-9]+\\.([0-9]+)_.*", "\\1", colnames(gse85241.df))
table(plate.id)
```

```
## plate.id
##   1   2   3   4   5   6   7   8 
## 384 384 384 384 384 384 384 384
```

Yet again, gene symbols were supplied instead of Ensembl or Entrez identifiers.
We convert all row names to Ensembl identifiers, removing `NA` or duplicated entries (with the exception of spike-in transcripts). 


```r
gene.symb <- gsub("__chr.*$", "", rownames(gse85241.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)
```

```
## is.spike
## FALSE  TRUE 
## 19059    81
```

```r
library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse85241.df <- gse85241.df[keep,]
rownames(gse85241.df) <- gene.ids[keep]
summary(keep)
```

```
##    Mode   FALSE    TRUE 
## logical    1949   17191
```

We create a `SingleCellExperiment` object to store the counts and metadata together.


```r
sce.gse85241 <- SingleCellExperiment(list(counts=as.matrix(gse85241.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse85241, "ERCC") <- grepl("^ERCC-", rownames(gse85241.df)) 
sce.gse85241  
```

```
## class: SingleCellExperiment 
## dim: 17191 3072 
## metadata(0):
## assays(1): counts
## rownames(17191): ENSG00000268895 ENSG00000121410 ... ENSG00000074755
##   ENSG00000036549
## rowData names(1): Symbol
## colnames(3072): D28.1_1 D28.1_2 ... D30.8_95 D30.8_96
## colData names(2): Donor Plate
## reducedDimNames(0):
## spikeNames(1): ERCC
```

### Quality control and normalization

We compute QC metrics for each cell and identify cells with low library sizes, low numbers of expressed genes, or high ERCC content.


```r
sce.gse85241 <- calculateQCMetrics(sce.gse85241, compact=TRUE)
QC <- sce.gse85241$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

```
##   LowLib LowNgenes HighSpike
## 1    577       669       696
```

Low-quality cells are defined as those with extreme values for these QC metrics and are removed.


```r
discard <- low.lib | low.genes | high.spike
sce.gse85241 <- sce.gse85241[,!discard]
summary(discard)
```

```
##    Mode   FALSE    TRUE 
## logical    2346     726
```

We compute size factors for the endogenous genes and spike-in transcripts, and use them to compute log-normalized expression values.


```r
set.seed(1000)
clusters <- quickCluster(sce.gse85241, use.ranks=FALSE, BSPARAM=IrlbaParam())
table(clusters)
```

```
## clusters
##   1   2   3   4   5   6   7   8 
## 280 393 259 207 384 247 374 202
```

```r
sce.gse85241 <- computeSumFactors(sce.gse85241, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse85241))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0878  0.5442  0.8263  1.0000  1.2127 14.6260
```

```r
sce.gse85241 <- computeSpikeFactors(sce.gse85241, general.use=FALSE)
summary(sizeFactors(sce.gse85241, "ERCC"))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.09295 0.61309 0.88902 1.00000 1.27519 4.04643
```

```r
sce.gse85241 <- normalize(sce.gse85241)
```

### Identifying highly variable genes

We fit a trend to the spike-in variances as previously described, allowing us to model the technical noise for each gene (Figure \@ref(fig:var-gse85241)).
Again, we set `block=` to ensure that uninteresting differences between plates or donors do not inflate the variance.


```r
block <- paste0(sce.gse85241$Plate, "_", sce.gse85241$Donor)
fit <- trendVar(sce.gse85241, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse85241, fit)
plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse85241)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

<div class="figure">
<img src="batch_files/figure-html/var-gse85241-1.png" alt="Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)." width="100%" />
<p class="caption">(\#fig:var-gse85241)Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).</p>
</div>

We order genes by decreasing biological component, as described above.


```r
dec.gse85241 <- dec
dec.gse85241$Symbol <- rowData(sce.gse85241)$Symbol
dec.gse85241 <- dec.gse85241[order(dec.gse85241$bio, decreasing=TRUE),]
head(dec.gse85241)
```

```
## DataFrame with 6 rows and 7 columns
##                             mean            total              bio
##                        <numeric>        <numeric>        <numeric>
## ENSG00000115263 7.65841710442871  6.5830512952663 6.55421179060075
## ENSG00000089199 4.61402548649295 6.40161547541309 6.27960849217962
## ENSG00000169903 3.00902736622973 6.52426016019893 6.16908131917692
## ENSG00000254647 1.99894035399136 6.41255303005657 5.85584323627252
## ENSG00000118271  7.3311379562758 5.71978094825155 5.68830339385946
## ENSG00000171951 4.18265117704755 5.54705848250118 5.38194664056256
##                               tech   p.value       FDR      Symbol
##                          <numeric> <numeric> <numeric> <character>
## ENSG00000115263 0.0288395046655466         0         0         GCG
## ENSG00000089199  0.122006983233466         0         0        CHGB
## ENSG00000169903  0.355178841022013         0         0      TM4SF4
## ENSG00000254647  0.556709793784048         0         0         INS
## ENSG00000118271 0.0314775543920864         0         0         TTR
## ENSG00000171951  0.165111841938628         0         0        SCG2
```



## Comments on additional batches

In @haghverdi2018batch, we originally performed batch correction across four separate pancreas scRNA-seq datasets.
For simplicity, we will only consider the two batches generated using CEL-seq(2) and ignore those generated using Smart-seq2 [@segerstolpe2016singlecell;@lawlor2017singlecell].
As one might expect, batch correction is easiest when dealing with data generated from the same technology,
as fewer systematic differences are present that can interfere with the biological structure.
Nonetheless, it is often possible to obtain good results when applying MNN correction to batches of data generated with different technologies.

It is also worth pointing out that both of the CEL-seq(2) batches above contain cells from multiple donors.
Each donor could be treated as a separate batch in their own right, 
reflecting (presumably uninteresting) biological differences between donors due to genotype, age, sex or other factors that are not easily controlled when dealing with humans.
For simplicity, we will ignore the donor effects within each study and only consider the removal of the batch effect between the two studies.
However, we note that it is possible to apply the MNN correction between donors in each batch and then between the batches - see `?fastMNN` for details.

# Feature selection across batches

To obtain a single set of features for batch correction, we compute the average biological component across all batches.
We then take all genes with positive biological components to ensure that all interesting biology is retained, equivalent to the behaviour of `denoisePCA()`.
However, the quality of the correction can often be sensitive to technical noise, which means that some discretion may be required during feature selection.
Users may prefer to take the top 1000-5000 genes with the largest average components, or to use `combineVar()` to obtain combined $p$-values for gene selection.


```r
universe <- intersect(rownames(dec.gse85241), rownames(dec.gse81076))
mean.bio <- (dec.gse85241[universe,"bio"] + dec.gse81076[universe,"bio"])/2
chosen <- universe[mean.bio > 0]
length(chosen)
```

```
## [1] 14749
```

We also rescale each batch to adjust for differences in sequencing depth between batches.
The `multiBatchNorm()` function recomputes log-normalized expression values after adjusting the size factors for systematic differences in coverage between `SingleCellExperiment` objects.
(Keep in mind that the previously computed size factors only remove biases between cells _within_ a single batch.)
This improves the quality of the correction by removing one aspect of the technical differences between batches.


```r
rescaled <- batchelor::multiBatchNorm(
    sce.gse85241[universe,], 
    sce.gse81076[universe,]
)
rescaled.gse85241 <- rescaled[[1]]
rescaled.gse81076 <- rescaled[[2]]
```

**Comments from Aaron:**

- Technically, we should have performed variance modelling and feature selection _after_ calling `multiBatchNorm()`.
This ensures that the variance components are estimated from the same values to be used in the batch correction.
In practice, this makes little difference, and it tends to be easier to process each batch separately and consolidate all results in one step as shown above.
- The `batchelor::` prefix avoids ambiguity during the migration of `multiBatchNorm()` from *[scran](https://bioconductor.org/packages/3.9/scran)* to *[batchelor](https://bioconductor.org/packages/3.9/batchelor)*.
This will not be necessary in the next release.

# Performing MNN-based correction

Consider a cell $a$ in batch $A$, and identify the cells in batch $B$ that are nearest neighbours to $a$ in the expression space defined by the selected features.
Repeat this for a cell $b$ in batch $B$, identifying its nearest neighbours in $A$.
Mutual nearest neighbours are pairs of cells from different batches that belong in each other's set of nearest neighbours.
The reasoning is that MNN pairs represent cells from the same biological state prior to the application of a batch effect - see @haghverdi2018batch for full theoretical details.
Thus, the difference between cells in MNN pairs can be used as an estimate of the batch effect, the subtraction of which can yield batch-corrected values.

We apply the `fastMNN()` function to the three batches to remove the batch effect, using the genes in `chosen`.
To reduce computational work and technical noise, all cells in all cells are projected into the low-dimensional space defined by the top `d` principal components.
Identification of MNNs and calculation of correction vectors are then performed in this low-dimensional space.
The function returns a `SingleCellExperiment` object containing low-dimensional corrected values for downstream analyses like clustering or visualization.


```r
set.seed(100) 
unc.gse81076 <- logcounts(rescaled.gse81076)[chosen,]
unc.gse85241 <- logcounts(rescaled.gse85241)[chosen,]

mnn.out <- batchelor::fastMNN(
    GSE81076=unc.gse81076, GSE85241=unc.gse85241,
    k=20, d=50, BSPARAM=IrlbaParam(deferred=TRUE)
)
mnn.out
```

```
## class: SingleCellExperiment 
## dim: 14749 3638 
## metadata(2): merge.order merge.info
## assays(1): reconstructed
## rownames(14749): ENSG00000115263 ENSG00000089199 ... ENSG00000125445
##   ENSG00000176731
## rowData names(1): rotation
## colnames(3638): D2ex_1 D2ex_2 ... D30.8_93 D30.8_94
## colData names(1): batch
## reducedDimNames(1): corrected
## spikeNames(0):
```

Each column of `mnn.out` corresponds to a cell in one of the batches, while each row corresponds to an input gene in `chosen`.
The `corrected` matrix in the `reducedDims` slot contains the low-dimensional corrected coordinates for all cells.


```r
dim(reducedDim(mnn.out, "corrected"))
```

```
## [1] 3638   50
```

The `batch` field in the column metadata contains an object specifying the batch of origin of each cell. 


```r
# Using an Rle for pretty-printing of batch IDs
# (as all cells from the same batch are consecutive).
Rle(mnn.out$batch) 
```

```
## character-Rle of length 3638 with 2 runs
##   Lengths:       1292       2346
##   Values : "GSE81076" "GSE85241"
```

Advanced users may also be interested in the list of `DataFrame`s in the `pairs` metadata field.
Each `DataFrame` describes the MNN pairs identified upon merging of each successive batch.
This may be useful for checking the identified MNN pairs against known cell type identity, e.g., to determine if the cell types are being paired correctly.


```r
metadata(mnn.out)$merge.info$pairs[[1]]
```

```
## DataFrame with 6606 rows and 2 columns
##          first    second
##      <integer> <integer>
## 1            1      1794
## 2            1      2087
## 3           15      1612
## 4           15      2512
## 5           15      2575
## ...        ...       ...
## 6602      1290      2339
## 6603      1290      1538
## 6604      1290      2794
## 6605      1290      2001
## 6606      1290      2731
```

As previously mentioned, we have only used two batches here to simplify the workflow.
However, the MNN approach is not limited to two batches, and inclusion of more batches is as simple as adding more `SingleCellExperiment` objects to the `fastMNN()` call.

**Comments from Aaron:**

- The `k=` parameter specifies the number of nearest neighbours to consider when defining MNN pairs.
This should be interpreted as the minimum frequency of each cell type or state in each batch.
  - Larger values will improve the precision of the correction by increasing the number of MNN pairs.
    It also provides some robustness to violations of the assumption that the batch vector is orthogonal to the biological subspace [@haghverdi2018batch],
    by allowing the neighbour search to ignore biological variation in each batch to identify the correct MNN pairs.
  - However, larger values of `k` can also reduce accuracy by allowing incorrect MNN pairs to form between cells of different types.
    Thus, we suggest starting with the default `k` and increasing it if one is confident that the same cell types are not adequately merged across batches.
    This is better than starting with a large `k` as incorrect merging is much harder to diagnose than insufficient merging.
- When `BSPARAM=IrlbaParam(deferred=TRUE)`, `fastMNN()` uses methods from the *[irlba](https://CRAN.R-project.org/package=irlba)* package to perform the principal components analysis quickly.
While the run-to-run differences should be minimal, it does mean that `set.seed()` is required to obtain fully reproducible results.
The `deferred=` argument instructs `fastMNN()` to sacrifice some numerical precision for greater speed.



# Examining the effect of correction

## By visualization

We examine the batch correction with some _t_-SNE plots.
Figure~\@ref(fig:tsne-batch) demonstrates how the cells separate by batch of origin in the uncorrected data.
After correction, more intermingling between batches is observed, consistent with the removal of batch effects.
Note that the E-MTAB-5601 dataset still displays some separation, which is probably due to the fact that the other batches are UMI datasets.


```r
# Adding uncorrected values.
sce <- mnn.out
assay(sce, "original") <- cbind(unc.gse81076, unc.gse85241)

# Using irlba to set up the t-SNE, for speed.
set.seed(100)
osce <- runPCA(sce, exprs_values="original", ntop=Inf, BSPARAM=IrlbaParam())
osce <- runTSNE(osce, use_dimred="PCA")
ot <- plotTSNE(osce, colour_by="batch") + ggtitle("Original")

# Corrected.
set.seed(100)
sce <- runTSNE(sce, use_dimred="corrected")
ct <- plotTSNE(sce, colour_by="batch") + ggtitle("Corrected")

multiplot(ot, ct, cols=2)
```

<div class="figure">
<img src="batch_files/figure-html/tsne-batch-1.png" alt="t-SNE plots of the pancreas datasets, before and after MNN correction. Each point represents a cell and is coloured by the batch of origin." width="960" />
<p class="caption">(\#fig:tsne-batch)t-SNE plots of the pancreas datasets, before and after MNN correction. Each point represents a cell and is coloured by the batch of origin.</p>
</div>

We colour by the expression of marker genes for known pancreas cell types to determine whether the correction is biologically sensible.
Cells in the same visual cluster express the same marker genes (Figure \@ref(fig:tsne-markers)), indicating that the correction maintains separation of cell types.


```r
# Replacing the row names for easier reference.
rowData(sce)$ENSEMBL <- rownames(sce)    
rowData(sce)$SYMBOL <- mapIds(org.Hs.eg.db, keytype="ENSEMBL", 
    keys=rownames(sce), column="SYMBOL")
rownames(sce) <- uniquifyFeatureNames(rownames(sce), rowData(sce)$SYMBOL)

ct.gcg <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="GCG") 
ct.ins <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="INS") 
ct.sst <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="SST") 
ct.ppy <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="PPY") 

multiplot(ct.gcg + ggtitle("Alpha cells"),
    ct.ins + ggtitle("Beta cells"),
    ct.sst + ggtitle("Delta cells"),
    ct.ppy + ggtitle("PP cells"),
    cols=2)
```

<div class="figure">
<img src="batch_files/figure-html/tsne-markers-1.png" alt="t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of key marker genes for known cell types in the pancreas." width="960" />
<p class="caption">(\#fig:tsne-markers)t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of key marker genes for known cell types in the pancreas.</p>
</div>

## With diagnostics

One useful diagnostic is the proportion of variance within each batch that is lost during MNN correction.
Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step. 
This is returned via the `lost.var` field in the metadata of `mnn.out`, which contains a matrix of the variance lost in each batch (column) at each merge step (row).


```r
metadata(mnn.out)$merge.info$lost.var
```

```
##             [,1]       [,2]
## [1,] 0.008302763 0.01110772
```

Large proportions of lost variance suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].
In this case, the proportion of lost variance is small, indicating that non-orthogonality is not a major concern.



# Controlling the merge order

## Manual specification 

The order of the supplied batches will affect the result as the first batch is used to define the reference space to which all other batches are corrected.
Specifically, the first batch is defined as the reference batch;
the second batch is corrected to and merged with the current reference batch, yielding a new reference batch;
and so on for all batches in the supplied order, with an increasingly large reference batch at each step.
The use of a merged reference ensures that information from batches other than the first are used to identify MNN pairs in later batches.

The order of batches to merge can be manually specified in the `auto.order=` argument to `fastMNN()`.
In the example shown below, batch 2 is treated as the reference as it is the first specified batch in `auto.order=`.
The first batch is then corrected to the second batch to obtain a new reference batch - and so on, if more than two batches were present.


```r
mnn.out2 <- batchelor::fastMNN(
    GSE81076=unc.gse81076, GSE85241=unc.gse85241,
    k=20, d=50, auto.order=c(2,1), BSPARAM=IrlbaParam(deferred=TRUE)
)
metadata(mnn.out2)$merge.order # batch 2 (GSE85241) is first in the order.
```

```
## [1] "GSE85241" "GSE81076"
```

```r
metadata(mnn.out2)$merge.info$pairs[[1]] # 'first' now refers to GSE85241.
```

```
## DataFrame with 6606 rows and 2 columns
##          first    second
##      <integer> <integer>
## 1         1294       748
## 2         1294       635
## 3         1294       963
## 4         1294      1206
## 5         1294       921
## ...        ...       ...
## 6602      3638       597
## 6603      3638      1274
## 6604      3638      1197
## 6605      3638      1188
## 6606      3638       724
```

Using `auto.order=` will change the merge order without requiring a change to the supplied order of batches in `fastMNN()`.
Similarly, the order of batches (and cells) in the output will not be altered.
This makes it easy to explore different merge orders without altering the surrounding code.


```r
Rle(mnn.out2$batch) # same as mnn.out$batch
```

```
## character-Rle of length 3638 with 2 runs
##   Lengths:       1292       2346
##   Values : "GSE81076" "GSE85241"
```

If very different batches (in terms of cell composition) are present, we suggest setting the largest, most heterogeneous batch as the first.
This ensures that sufficient MNN pairs will be identified between the first and other batches for stable correction.
Conversely, if two small batches without shared populations are supplied first, the wrong MNN pairs will be detected and the result of the merge will be incorrect.



## Hierarchical merging 

### Motivation  

In more complex experiments, we may know beforehand that certain sets of batches are more similar to each other.
We might then want to merge those similar batches before attempting the more difficult merges involving batches with different cell type composition and/or gene expression.
Examples include:

- Merging batches that represent replicate experiments from the same condition, prior to merging across conditions.
- Merging batches generated with the same scRNA-seq technology prior to merging across technologies.

This strategy limits encourages detection of correct MNN pairs as similar batches should have more shared populations, 
By comparison, performing the more difficult merges first is more likely to introduce errors whereby distinct subpopulations are incorrectly placed together.
This unnecessarily propagates the error to later steps as the initial merge is used as a reference for subsequent merges.

### Setting up the inputs

Hierarchical merging can be achieved through multiple calls to `fastMNN()` with progressively merged batches.
To illustrate, assume that we want to remove `Donor` effects within each batch prior to merging across batches.
We split up the cells in GSE85241 according to the donor of origin, creating one `SingleCellExperiment` object for each donor.


```r
all.donors <- unique(rescaled.gse85241$Donor)
table(rescaled.gse85241$Donor)
```

```
## 
## D28 D29 D30 D31 
## 340 604 689 713
```

```r
by.donor.85241 <- vector("list", length(all.donors))
names(by.donor.85241) <- sort(all.donors)
for (x in all.donors) {
    by.donor.85241[[x]] <- rescaled.gse85241[,rescaled.gse85241$Donor==x]
}
```

We repeat this process for GSE81076.
For demonstration purposes, we will aggregate some of the donors together to ensure that there are enough cells in each level for MNN detection.


```r
adj.donors <- c(D101="A", D102="A", D10631="A",
    D17="B", D1713="B", D172444="B",
    D2="C", D3="C",
    D71="D", D72="D", D73="D", D74="D")[rescaled.gse81076$Donor]
table(adj.donors)
```

```
## adj.donors
##   A   B   C   D 
## 162 464 320 346
```

```r
all.donors <- unique(adj.donors)
by.donor.81076 <- vector("list", length(all.donors))
names(by.donor.81076) <- sort(all.donors)
for (x in all.donors) {
    by.donor.81076[[x]] <- rescaled.gse81076[,adj.donors==x]
}
```

We use the `multiBatchPCA()` function to perform a PCA across _all_ batches to be merged.
This ensures that all cells are placed onto the same coordinate space, which would obviously not be possible if a PCA was performed for each batch separately.
Specifically, `multiBatchPCA()` performs a modified PCA to ensure that each supplied matrix contributes equally to the definition of the PC space.
This avoids problems with imbalances in the number of cells across batches, meanining that smaller batches (possibly with unique cell types) are not ignored.


```r
all.batches <- c(by.donor.85241, by.donor.81076)

# Cosine normalizing for consistency with fastMNN() defaults.
all.logcounts <- lapply(all.batches, logcounts)
scaled <- lapply(all.logcounts, batchelor::cosineNorm) 

set.seed(1000) # for irlba.
pc.all <- do.call(batchelor::multiBatchPCA, c(scaled, 
    list(d=50, BSPARAM=IrlbaParam(deferred=TRUE))
))
names(pc.all)
```

```
## [1] "D28" "D29" "D30" "D31" "A"   "B"   "C"   "D"
```

**Comments from Aaron:**

- Here, we have applied `multiBatchPCA()` to the batch-level inputs for convenience.
It is also possible to supply donor-level matrices to equalize contributions across donors.
- Recall that we ran `multiBatchNorm()` earlier to generate the `rescaled.gse*` objects.
As a result, cosine normalization is not technically necessary, as all batches should be on the same scale already (see `?cosineNorm` for a discussion of this).
Nonetheless, we run it here for consistency with our previous `fastMNN()` call where cosine normalization is turned on by default.

### Performing progressive merges 

We pass the matrices corresponding to the donors in GSE85241 to `fastMNN()`, setting `pc.input=TRUE` to indicate that dimensionality reduction has already been performed.
This uses the first donor to define the reference space^[Which can be changed with `auto.order=`, if so desired.] and merges cells from all other donors to the first.
In this manner, we remove donor effects within the GSE85241 batch.


```r
pcs.85241 <- pc.all[seq_along(by.donor.85241)]
mnn.out.85241 <- do.call(batchelor::fastMNN, c(pcs.85241, list(pc.input=TRUE)))
Rle(mnn.out.85241$batch)
```

```
## character-Rle of length 2346 with 4 runs
##   Lengths:   340   604   689   713
##   Values : "D28" "D29" "D30" "D31"
```

Note that when `pc.input=TRUE`, a `DataFrame` is returned instead of a `SingleCellExperiment`.
This reflects the fact that per-gene identities are lost when PCs are supplied instead of per-gene expression vectors^[Though it is entirely possible to reconstruct these using rotation vectors, see below.].
We repeat this for the donors in the GSE81076 batch.


```r
pcs.81076 <- tail(pc.all, length(by.donor.81076))
mnn.out.81076 <- do.call(batchelor::fastMNN, c(pcs.81076, list(pc.input=TRUE)))
Rle(mnn.out.81076$batch)
```

```
## character-Rle of length 1292 with 4 runs
##   Lengths: 162 464 320 346
##   Values : "A" "B" "C" "D"
```

The next step is to merge the two batches together.
To do this, we simply repeat the `fastMNN()` call with the donor-corrected values for each batch.
Again, we need to set `pc.input=TRUE` to prevent the function from unnecessarily (and incorrectly) repeating the cosine normalization and PCA steps on the corrected values.
We use a larger `k` in the final `fastMNN()` call to improve the robustness of MNN detection to outlier cells on the edges of each cluster.


```r
mnn.out3 <- batchelor::fastMNN(
    GSE81076=mnn.out.81076,
    GSE85241=mnn.out.85241, 
    pc.input=TRUE, k=100 # see comments below.
) 

Rle(mnn.out3$batch) # by dataset
```

```
## character-Rle of length 3638 with 2 runs
##   Lengths:       1292       2346
##   Values : "GSE81076" "GSE85241"
```

```r
Rle(c(mnn.out.81076$batch, mnn.out.85241$batch)) # by donor
```

```
## character-Rle of length 3638 with 8 runs
##   Lengths:   162   464   320   346   340   604   689   713
##   Values :   "A"   "B"   "C"   "D" "D28" "D29" "D30" "D31"
```

This yields a final corrected expression matrix where both within-batch donor effects and batch effects have been corrected.
We examine the quality of each of the merge steps with t-SNE plots (Figure \@ref(fig:tsne-hmerge)).
Within each batch, the donors are generally well-mixed, and the final merge is consistent with Figure \@ref(fig:tsne-batch). 


```r
set.seed(1000)
par(mfrow=c(1,3))

library(Rtsne)
tout.85241 <- Rtsne(mnn.out.85241$corrected, pca=FALSE)
plot(tout.85241$Y[,1], tout.85241$Y[,2], main="GSE85241 donors",
    col=as.factor(mnn.out.85241$batch), xlab="tSNE1", ylab="tSNE2")

tout.81076 <- Rtsne(mnn.out.81076$corrected, pca=FALSE)
plot(tout.81076$Y[,1], tout.81076$Y[,2], main="GSE81076 donors",
    col=as.factor(mnn.out.81076$batch), xlab="tSNE1", ylab="tSNE2")

tout.all <- Rtsne(mnn.out3$corrected, pca=FALSE)
plot(tout.all$Y[,1], tout.all$Y[,2], main="Final",
    col=as.factor(mnn.out3$batch), xlab="tSNE1", ylab="tSNE2")
```

<div class="figure">
<img src="batch_files/figure-html/tsne-hmerge-1.png" alt="t-SNE plots after correcting for donor effects within each data set, and after correcting for batch effects between data sets (final). Each point represents a cell that is coloured according to its donor of origin (left, middle) or the data set of origin (right)." width="960" />
<p class="caption">(\#fig:tsne-hmerge)t-SNE plots after correcting for donor effects within each data set, and after correcting for batch effects between data sets (final). Each point represents a cell that is coloured according to its donor of origin (left, middle) or the data set of origin (right).</p>
</div>

**Comments from Aaron:**

- Here, we have applied `multiBatchPCA()` to the batch-level inputs for convenience.
It is also possible to supply donor-level matrices to equalize contributions across donors.
- One might ask why a larger `k` was not needed in Figure \@ref(fig:tsne-batch) as well.
This was probably because the outliers were masked by inter-donor heterogeneity when the t-SNE plots were generated without removing the donor effects.
- In this specific example, cells from the same donor will occupy contiguous rows in the `mnn.out3$corrected` matrix.
However, this may not have been the case for the original ordering of cells in each `SingleCellExperiment`.
This requires some extra account-keeping to match up the final corrected matrix to the original ordering, e.g., when cross-referencing to metadata.

    
    ```r
    original.plate <- unlist(lapply(rescaled, "[[", i="Plate"))
    original.names <- unlist(lapply(rescaled, colnames))
    
    # Needs unique names: trigger error otherwise.
    stopifnot(anyDuplicated(original.names)==0L)
    
    m <- match(rownames(mnn.out3$corrected), original.names)
    new.plate <- original.plate[m]
    ```



## Automatic specification

In situations where the nature of each batch is unknown, users can set `auto.order=TRUE` to allow `fastMNN()` to empirically choose which batches to merge at each step.
The first merge is performed between the pair of batches with the most MNN pairs.
Progressive merges are performed with the remaining batch that has the most MNN pairs with the current reference batch.
The aim is to maximize the number of MNN pairs at each step to provide a stable correction.
We demonstrate below using the within-donor subbatches in the GSE81076 data set.


```r
mnn.out.auto <- do.call(batchelor::fastMNN, c(pcs.81076, 
    list(pc.input=TRUE, auto.order=TRUE)))
names(by.donor.81076) # supplied order 
```

```
## [1] "A" "B" "C" "D"
```

```r
metadata(mnn.out.auto)$merge.order # automatically defined order
```

```
## [1] "D" "B" "C" "A"
```

As with manual specification, the merge order does not affect the output order of cells.
This makes it easy to try different merge orderings without having to deal with a re-ordering of output cells.


```r
Rle(mnn.out.auto$batch) 
```

```
## character-Rle of length 1292 with 4 runs
##   Lengths: 162 464 320 346
##   Values : "A" "B" "C" "D"
```

The obvious cost of this approach is that of computation time. 
Nearest-neighbour searches need to be performed between all pairs of batches, and then between each remaining batch and the reference at each merge step.
As such, we prefer manual definition of a merge order that makes better use of prior knowledge about the experiment design.



# Using the corrected values in downstream analyses

## For cell-based analyses

The low-dimensional corrected values can be used in any procedure that involves computing and comparing cell-cell (Euclidean) distances.
Recall that the aim of batch correction is to bring together related cells from different batches while preserving biological differences between cells within each batch.
The exact values of the corrected coordinates may not be interpretable, but this is not a problem if we are interested in the relative magnitudes of the distances.
For example, the code below directly uses the MNN-corrected values for clustering. 


```r
snn.gr <- buildSNNGraph(sce, use.dimred="corrected")
clusters <- igraph::cluster_walktrap(snn.gr)
table(clusters$membership, sce$batch)
```

```
##     
##      GSE81076 GSE85241
##   1       331      283
##   2        53        0
##   3       354      262
##   4       216      847
##   5       160      413
##   6        64      198
##   7        25      108
##   8        22      126
##   9        52       66
##   10        0       18
##   11        8        4
##   12        7       21
```

Figure \@ref(fig:tsne-cluster) shows strong correspondence between the cluster labels and separation in _t_-SNE space.


```r
sce$Cluster <- factor(clusters$membership)
plotTSNE(sce, colour_by="Cluster")
```

<div class="figure">
<img src="batch_files/figure-html/tsne-cluster-1.png" alt="t-SNE plot after MMN correction, where each point represents a cell and is coloured by its cluster identity." width="100%" />
<p class="caption">(\#fig:tsne-cluster)t-SNE plot after MMN correction, where each point represents a cell and is coloured by its cluster identity.</p>
</div>

The corrected values can be used in any procedure that operates on cell-cell distances.
This includes nearest-neighbor searches, non-linear visualization like _t_-SNE and trajectory inference.

## For gene-based analyses

For gene-based procedures like differential expression (DE) analyses or gene network construction, it is desirable to use the **original** log-expression values or counts.
The corrected values are only used to obtain cell-level results such as clusters or trajectories.
Batch effects are handled explicitly using blocking terms or via a meta-analysis across batches. 
We do not use the corrected values directly in gene-based analyses, for various reasons:

- It is usually inappropriate to perform DE analyses on batch-corrected values, due to the failure to model the uncertainty of the correction.
This usually results in loss of type I error control, i.e., more false positives than expected.
- The correction does not preserve the mean-variance relationship.
Applications of common DE methods like *[edgeR](https://bioconductor.org/packages/3.9/edgeR)* or *[limma](https://bioconductor.org/packages/3.9/limma)* are unlikely to be valid.
- Batch correction may (correctly) remove biological differences between batches in the course of mapping all cells onto a common coordinate system.
Returning to the uncorrected expression values provides an opportunity for detecting such differences if they are of interest.
Conversely, if the batch correction made a mistake, the use of the uncorrected expression values provides an important sanity check.

Indeed, in the specific case of `fastMNN()`, the batch-corrected values no longer correspond to per-gene expression values anyway.
This means that they cannot be directly used in gene-based analyses^[Though one can circumvent this, see below.].

Users should generally aim to avoid using batch-corrected values for per-gene analyses when within-batch alternatives are available. 
To illustrate, we perform a DE analysis on the uncorrected expression data using the clusters identified previously.
To model the batch effect, we set the batch of origin as the `block=` argument in `findMarkers()`.
This will perform all comparisons between clusters _within_ each batch, and then combine the $p$-values to consolidate results across batches.


```r
m.out <- findMarkers(sce, clusters$membership, block=sce$batch,
    direction="up", assay.type="original")
demo <- m.out[["4"]] # probably alpha cells.
demo <- demo[demo$Top <= 5,]
as.data.frame(demo[,1:3]) # only first three columns for brevity.
```

```
##         Top       p.value           FDR
## TM4SF4    1  0.000000e+00  0.000000e+00
## TTR       1  0.000000e+00  0.000000e+00
## PPP1R1A   1  0.000000e+00  0.000000e+00
## IRX2      1  0.000000e+00  0.000000e+00
## FAP       1  0.000000e+00  0.000000e+00
## PTPRN2    1  0.000000e+00  0.000000e+00
## CNTN1     1  0.000000e+00  0.000000e+00
## ARX       1  0.000000e+00  0.000000e+00
## CPE       2  0.000000e+00  0.000000e+00
## CHGB      2  0.000000e+00  0.000000e+00
## PAX6      2  0.000000e+00  0.000000e+00
## GC        2  0.000000e+00  0.000000e+00
## SCG2      2  0.000000e+00  0.000000e+00
## CRYBA2    2  0.000000e+00  0.000000e+00
## PAM       2  0.000000e+00  0.000000e+00
## SYT7      2  0.000000e+00  0.000000e+00
## LOXL4     2 8.624621e-293 1.718980e-290
## MAFB      3  0.000000e+00  0.000000e+00
## SCGN      3  0.000000e+00  0.000000e+00
## SEZ6L2    3  0.000000e+00  0.000000e+00
## TPD52     3  0.000000e+00  0.000000e+00
## PLCE1     3 2.554347e-194 2.165176e-192
## PTPRN     4  0.000000e+00  0.000000e+00
## SLC30A8   4  0.000000e+00  0.000000e+00
## GCG       4  0.000000e+00  0.000000e+00
## SLC38A4   4  0.000000e+00  0.000000e+00
## RAB3B     4  0.000000e+00  0.000000e+00
## RCAN2     4 7.698142e-283 1.384633e-280
## PCSK2     5  0.000000e+00  0.000000e+00
## DDR1      5  0.000000e+00  0.000000e+00
## FABP5     5 2.166088e-268 3.435230e-266
## CFC1      5 3.077295e-265 4.631329e-263
```



Other approaches for handling batch effects during marker gene detection are discussed [elsewhere](https://bioconductor.org/packages/3.9/simpleSingleCell/vignettes/de.html#blocking-on-uninteresting-factors-of-variation).
It is similarly possible to perform these analyses with standard Bioconductor packages for DE analysis such as *[edgeR](https://bioconductor.org/packages/3.9/edgeR)* or *[limma](https://bioconductor.org/packages/3.9/limma)*.
Note that the use of `block=` is roughly similar to the use of a batch-cluster interaction model and testing whether the average log-fold change across batches is equal to zero.

**Comments from Aaron:**

- Users of the older `mnnCorrect()` function will note that the function returned corrected expression values.
It is tempting to use these corrected values directly for DE analyses, but this would likely be inappropriate.
In addition to the reasons discussed above, the default parameters of `mnnCorrect()` do not return corrected values on the log-scale, but rather a cosine-normalized log-scale.
This makes it difficult to interpret the effect size of DE analyses based on the corrected values.

## Obtaining per-gene corrected values

When applied on gene expression values, `fastMNN()` will also return a matrix of corrected per-gene expression values in the `reconstructed` assay.
This is obtained by taking the cross-product of the corrected low-dimensional values with the rotation vectors from the initial PCA,
which effectively reverses the initial projection into a low-dimensional space during `multiBatchPCA()`.
The example below extracts the corrected expression values for insulin.


```r
assay(sce, "reconstructed")
```

```
## <14749 x 3638> LowRankMatrix object of type "double":
##                 D2ex_1        D2ex_2        D2ex_3 ...      D30.8_93
##      GCG   -0.05526316   -0.05141687   -0.05723824   . -0.0156577088
##     CHGB   -0.03027020   -0.02882877   -0.02987687   . -0.0260985856
##   TM4SF4   -0.02502889   -0.03030008   -0.02811667   . -0.0071650507
##      INS   -0.02186186   -0.02002987   -0.01670812   .  0.0006917939
##      TTR   -0.05446810   -0.05892382   -0.05018306   . -0.0309831411
##      ...             .             .             .   .             .
## CSNK1A1L -0.0002280876 -0.0003439194 -0.0004017156   . -6.712927e-04
##   COMMD1  0.0004292420 -0.0010684774 -0.0006444401   .  2.250520e-03
##    INTS5  0.0002367847 -0.0001885313  0.0001929512   .  1.098893e-03
##    MRPS7  0.0019667583  0.0021769483  0.0015019780   .  2.754416e-03
##  C8orf59  0.0045369719  0.0054612439  0.0045204911   .  1.527616e-03
##               D30.8_94
##      GCG -0.0319662709
##     CHGB -0.0232760816
##   TM4SF4 -0.0133403623
##      INS -0.0053620141
##      TTR -0.0276138964
##      ...             .
## CSNK1A1L -4.685546e-04
##   COMMD1  1.547545e-03
##    INTS5  1.190677e-03
##    MRPS7  2.253767e-03
##  C8orf59  4.837195e-05
```

```r
summary(assay(sce)["INS",])
```

```
##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## -0.036427 -0.005647  0.002908  0.014220  0.013827  0.101760
```

If `fastMNN()` was run on low-dimensional inputs, only the low-dimensional output will be reported.
Nonetheless, users can obtain per-gene corrected values by manually computing the cross-product using the PCA rotation vectors.
For example, the code below obtains corrected expression values for _GCG_ from our hierarchical merge.


```r
rotations <- metadata(pc.all)$rotation
cor.exp <- tcrossprod(mnn.out3$corrected,
    rotations["ENSG00000115263",,drop=FALSE])
summary(cor.exp)
```

```
##  ENSG00000115263    
##  Min.   :-0.075060  
##  1st Qu.:-0.039001  
##  Median :-0.028673  
##  Mean   :-0.018673  
##  3rd Qu.: 0.009218  
##  Max.   : 0.071943
```

Explicit calculation of all per-gene corrected values is probably ill-advised as this would involve the construction of a dense matrix.
This may be prohibitively memory-consuming for large data sets that are otherwise representable as sparse matrices.
Rather, corrected values can be computed for specific genes as they are needed, e.g., using the `LowRankMatrix` class.

Per-gene corrected values can be readily used for visualization, e.g., in Figure \@ref(fig:tsne-markers).
This can be more aesthetically pleasing than uncorrected expression values that may contain large shifts on the colour scale between cells in different batches.
However, use of the corrected values in any quantitative procedure should be treated with extreme caution.
If they must be used, they should be backed up by similar results from an analysis on the uncorrected values.

# Concluding remarks

We save the `SingleCellExperiment` object for use elsewhere.
This avoids the need to repeat all of the processing steps described above.


```r
saveRDS(file="pancreas_data.rds", sce)
```

All software packages used in this workflow are publicly available from the Comprehensive R Archive Network (https://cran.r-project.org) or the Bioconductor project (http://bioconductor.org).
The specific version numbers of the packages used are shown below, along with the version of the R installation.


```r
sessionInfo()
```

```
## R Under development (unstable) (2019-04-11 r76379)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 18.04.2 LTS
## 
## Matrix products: default
## BLAS:   /home/luna/Software/R/trunk/lib/libRblas.so
## LAPACK: /home/luna/Software/R/trunk/lib/libRlapack.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    parallel  stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] Rtsne_0.15                  BiocSingular_0.99.15       
##  [3] scran_1.11.26               scater_1.11.16             
##  [5] ggplot2_3.1.1               SingleCellExperiment_1.5.2 
##  [7] SummarizedExperiment_1.13.0 DelayedArray_0.9.9         
##  [9] BiocParallel_1.17.18        matrixStats_0.54.0         
## [11] GenomicRanges_1.35.1        GenomeInfoDb_1.19.3        
## [13] org.Hs.eg.db_3.7.0          AnnotationDbi_1.45.1       
## [15] IRanges_2.17.4              S4Vectors_0.21.23          
## [17] Biobase_2.43.1              BiocGenerics_0.29.2        
## [19] BiocFileCache_1.7.9         dbplyr_1.3.0               
## [21] knitr_1.22                  BiocStyle_2.11.0           
## 
## loaded via a namespace (and not attached):
##  [1] bitops_1.0-6             bit64_0.9-7             
##  [3] httr_1.4.0               dynamicTreeCut_1.63-1   
##  [5] tools_3.7.0              R6_2.4.0                
##  [7] irlba_2.3.3              vipor_0.4.5             
##  [9] DBI_1.0.0                lazyeval_0.2.2          
## [11] colorspace_1.4-1         withr_2.1.2             
## [13] tidyselect_0.2.5         gridExtra_2.3           
## [15] processx_3.3.0           bit_1.1-14              
## [17] curl_3.3                 compiler_3.7.0          
## [19] BiocNeighbors_1.1.13     labeling_0.3            
## [21] bookdown_0.9             scales_1.0.0            
## [23] callr_3.2.0              rappdirs_0.3.1          
## [25] stringr_1.4.0            digest_0.6.18           
## [27] rmarkdown_1.12           XVector_0.23.2          
## [29] pkgconfig_2.0.2          htmltools_0.3.6         
## [31] highr_0.8                limma_3.39.14           
## [33] rlang_0.3.4              RSQLite_2.1.1           
## [35] DelayedMatrixStats_1.5.2 dplyr_0.8.0.1           
## [37] RCurl_1.95-4.12          magrittr_1.5            
## [39] simpleSingleCell_1.7.20  GenomeInfoDbData_1.2.1  
## [41] Matrix_1.2-17            Rcpp_1.0.1              
## [43] ggbeeswarm_0.6.0         munsell_0.5.0           
## [45] viridis_0.5.1            stringi_1.4.3           
## [47] yaml_2.2.0               edgeR_3.25.3            
## [49] zlibbioc_1.29.0          plyr_1.8.4              
## [51] grid_3.7.0               blob_1.1.1              
## [53] dqrng_0.1.1              crayon_1.3.4            
## [55] lattice_0.20-38          cowplot_0.9.4           
## [57] locfit_1.5-9.1           ps_1.3.0                
## [59] pillar_1.3.1             igraph_1.2.4            
## [61] codetools_0.2-16         glue_1.3.1              
## [63] evaluate_0.13            BiocManager_1.30.4      
## [65] batchelor_0.99.7         gtable_0.3.0            
## [67] purrr_0.3.2              assertthat_0.2.1        
## [69] xfun_0.6                 rsvd_1.0.0              
## [71] viridisLite_0.3.0        tibble_2.1.1            
## [73] beeswarm_0.2.3           memoise_1.1.0           
## [75] statmod_1.4.30
```

# References

