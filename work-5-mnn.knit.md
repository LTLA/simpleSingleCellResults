---
title: Correcting batch effects in single-cell RNA-seq data
author: 
- name: Aaron T. L. Lun
  affiliation: Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
- name: Michael D. Morgan
  affiliation: Wellcome Trust Sanger Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SA, United Kingdom
date: "2018-09-08"
vignette: >
  %\VignetteIndexEntry{5. Correcting batch effects in scRNA-seq data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
output: 
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
bibliography: ref.bib
---



# Introduction

Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints.
However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality.
This results in systematic differences in the observed expression in cells from different batches, which we refer to as "batch effects".
Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.

Computational correction of these effects is critical for eliminating batch-to-batch variation, allowing data across multiple batches to be combined for valid downstream analysis.
However, existing methods such as `removeBatchEffect()` [@ritchie2015limma] assume that the composition of cell populations are either known or the same across batches.
This workflow describes the application of an alternative strategy for batch correction based on the detection of mutual nearest neighbours (MNNs) [@haghverdi2018batch].
The MNN approach does not rely on pre-defined or equal population compositions across batches, only requiring that a subset of the population be shared between batches.
We demonstrate its use on two human pancreas scRNA-seq datasets generated in separate studies.

# Processing the different datasets

## CEL-seq, GSE81076

### Loading in the data

This dataset was generated by @grun2016denovo using the CEL-seq protocol with unique molecular identifiers (UMIs) and ERCC spike-ins.
Count tables were obtained from the NCBI Gene Expression Omnibus using the accession number above.


```r
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
grun.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE81nnn/GSE81076/suppl/GSE81076%5FD2%5F3%5F7%5F10%5F17%2Etxt%2Egz"))
```

We first read the table into memory.


```r
gse81076.df <- read.table(grun.fname, sep='\t', 
    header=TRUE, stringsAsFactors=FALSE, row.names=1)
dim(gse81076.df)
```

```
## [1] 20148  1728
```

Unfortunately, the data and metadata are all mixed together in this file.
As a result, we need to manually extract the metadata from the column names.


```r
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse81076.df))
table(donor.names)
```

```
## donor.names
##    D101    D102  D10631     D17   D1713 D172444      D2      D3     D71 
##      96      96      96     288      96      96      96     480      96 
##     D72     D73     D74 
##      96      96      96
```

```r
plate.id <- sub("^D[0-9]+(.*)_.*", "\\1", colnames(gse81076.df))
table(plate.id)
```

```
## plate.id
##      All1 All2  en1  en2  en3  en4   ex TGFB 
##  864   96   96   96   96   96   96  192   96
```

Another irritating feature of this dataset is that gene symbols were supplied, rather than stable identifiers such as Ensembl.
We convert all row names to Ensembl identifiers, removing `NA` or duplicated entries (with the exception of spike-in transcripts). 


```r
gene.symb <- gsub("__chr.*$", "", rownames(gse81076.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)
```

```
## is.spike
## FALSE  TRUE 
## 20064    84
```

```r
library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse81076.df <- gse81076.df[keep,]
rownames(gse81076.df) <- gene.ids[keep]
summary(keep)
```

```
##    Mode   FALSE    TRUE 
## logical    2252   17896
```

We create a `SingleCellExperiment` object to store the counts and metadata together.
This reduces the risk of book-keeping errors in later steps of the analysis.
Note that we re-identify the spike-in rows, as the previous indices would have changed after the subsetting.


```r
library(SingleCellExperiment)
sce.gse81076 <- SingleCellExperiment(list(counts=as.matrix(gse81076.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse81076, "ERCC") <- grepl("^ERCC-", rownames(gse81076.df)) 
sce.gse81076  
```

```
## class: SingleCellExperiment 
## dim: 17896 1728 
## metadata(0):
## assays(1): counts
## rownames(17896): ENSG00000268895 ENSG00000121410 ... ENSG00000074755
##   ENSG00000036549
## rowData names(1): Symbol
## colnames(1728): D2ex_1 D2ex_2 ... D17TGFB_95 D17TGFB_96
## colData names(2): Donor Plate
## reducedDimNames(0):
## spikeNames(1): ERCC
```

### Quality control and normalization

We compute quality control (QC) metrics for each cell [@mccarthy2017scater] and identify cells with low library sizes, low numbers of expressed genes, or high ERCC content.


```r
library(scater)
sce.gse81076 <- calculateQCMetrics(sce.gse81076, compact=TRUE)
QC <- sce.gse81076$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

```
##   LowLib LowNgenes HighSpike
## 1     54       130       389
```

Cells with extreme values for these QC metrics are presumed to be of low quality and are removed.
A more thorough analysis would examine the distributions of these QC metrics beforehand, but we will skip that step for brevity here.


```r
discard <- low.lib | low.genes | high.spike
sce.gse81076 <- sce.gse81076[,!discard]
summary(discard)
```

```
##    Mode   FALSE    TRUE 
## logical    1291     437
```

We compute size factors for the endogenous genes using the deconvolution method [@lun2016pooling].
This is done with pre-clustering through `quickCluster()` to avoid pooling together very different cells.


```r
library(scran)
set.seed(1000)    
clusters <- quickCluster(sce.gse81076, method="igraph", min.mean=0.1)
table(clusters)
```

```
## clusters
##   1   2   3 
## 510 447 334
```

```r
sce.gse81076 <- computeSumFactors(sce.gse81076, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse81076))
```

```
##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
## 0.003647 0.439492 0.795647 1.000000 1.306499 9.537246
```

We also compute size factors for the spike-in transcripts [@lun2017assessing].
Recall that we set `general.use=FALSE` to ensure that the spike-in size factors are only applied to the spike-in transcripts.


```r
sce.gse81076 <- computeSpikeFactors(sce.gse81076, general.use=FALSE)
summary(sizeFactors(sce.gse81076, "ERCC"))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.01042 0.57800 0.88697 1.00000 1.27728 7.44245
```

We then compute normalized log-expression values for use in downstream analyses.


```r
sce.gse81076 <- normalize(sce.gse81076)
```

### Identifying highly variable genes

We identify highly variable genes (HVGs) using `trendVar()` and `decomposeVar()`, using the variances of spike-in transcripts to model technical noise.
We set `block=` to ensure that uninteresting differences between plates or donors do not inflate the variance.
The small discrepancy in the fitted trend in Figure \@ref(fig:var-gse81076) is caused by the fact that the trend is fitted robustly to the block-wise variances of the spike-ins, 
while the variances shown are averaged across blocks and not robust to outliers.


```r
block <- paste0(sce.gse81076$Plate, "_", sce.gse81076$Donor)
fit <- trendVar(sce.gse81076, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse81076, fit)

plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse81076)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/var-gse81076-1.png" alt="Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)." width="100%" />
<p class="caption">(\#fig:var-gse81076)Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).</p>
</div>

We order genes by decreasing biological component, revealing some usual suspects such as insulin and glucagon.
We will be using this information later when performing feature selection prior to running `mnnCorrect()`.


```r
dec.gse81076 <- dec
dec.gse81076$Symbol <- rowData(sce.gse81076)$Symbol
dec.gse81076 <- dec.gse81076[order(dec.gse81076$bio, decreasing=TRUE),]
head(dec.gse81076)
```

```
## DataFrame with 6 rows and 7 columns
##                             mean            total              bio
##                        <numeric>        <numeric>        <numeric>
## ENSG00000254647 2.82375213355122 6.23371017274873 5.78925369051324
## ENSG00000115263 4.00502030222418 5.57298472593325 5.34000203633559
## ENSG00000118271 3.65394515670301 5.56852620829942 5.26638758669568
## ENSG00000115386 4.24975358274725 5.44809451134971 5.21291626864515
## ENSG00000164266 3.04229521742136 5.46060429009149 5.05466377200976
## ENSG00000172023 2.46457350475545 5.31719477182064 4.92410031811394
##                              tech   p.value       FDR      Symbol
##                         <numeric> <numeric> <numeric> <character>
## ENSG00000254647 0.444456482235487         0         0         INS
## ENSG00000115263 0.232982689597652         0         0         GCG
## ENSG00000118271  0.30213862160374         0         0         TTR
## ENSG00000115386 0.235178242704565         0         0       REG1A
## ENSG00000164266 0.405940518081734         0         0      SPINK1
## ENSG00000172023 0.393094453706702         0         0       REG1B
```



## CEL-seq2, GSE85241

### Loading in the data

This dataset was generated by @muraro2016singlecell using the CEL-seq2 protocol with unique molecular identifiers (UMIs) and ERCC spike-ins.
Count tables were obtained from the NCBI Gene Expression Omnibus using the accession number above.


```r
muraro.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE85nnn/GSE85241/suppl",
    "GSE85241%5Fcellsystems%5Fdataset%5F4donors%5Fupdated%2Ecsv%2Egz"))
```

We first read the table into memory.


```r
gse85241.df <- read.table(muraro.fname, sep='\t', 
    header=TRUE, row.names=1, stringsAsFactors=FALSE)
dim(gse85241.df)
```

```
## [1] 19140  3072
```

We extract the metadata from the column names.


```r
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse85241.df))
table(donor.names)
```

```
## donor.names
## D28 D29 D30 D31 
## 768 768 768 768
```

```r
plate.id <- sub("^D[0-9]+\\.([0-9]+)_.*", "\\1", colnames(gse85241.df))
table(plate.id)
```

```
## plate.id
##   1   2   3   4   5   6   7   8 
## 384 384 384 384 384 384 384 384
```

Yet again, gene symbols were supplied instead of Ensembl or Entrez identifiers.
We convert all row names to Ensembl identifiers, removing `NA` or duplicated entries (with the exception of spike-in transcripts). 


```r
gene.symb <- gsub("__chr.*$", "", rownames(gse85241.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)
```

```
## is.spike
## FALSE  TRUE 
## 19059    81
```

```r
library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse85241.df <- gse85241.df[keep,]
rownames(gse85241.df) <- gene.ids[keep]
summary(keep)
```

```
##    Mode   FALSE    TRUE 
## logical    2097   17043
```

We create a `SingleCellExperiment` object to store the counts and metadata together.


```r
sce.gse85241 <- SingleCellExperiment(list(counts=as.matrix(gse85241.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse85241, "ERCC") <- grepl("^ERCC-", rownames(gse85241.df)) 
sce.gse85241  
```

```
## class: SingleCellExperiment 
## dim: 17043 3072 
## metadata(0):
## assays(1): counts
## rownames(17043): ENSG00000268895 ENSG00000121410 ... ENSG00000074755
##   ENSG00000036549
## rowData names(1): Symbol
## colnames(3072): D28.1_1 D28.1_2 ... D30.8_95 D30.8_96
## colData names(2): Donor Plate
## reducedDimNames(0):
## spikeNames(1): ERCC
```

### Quality control and normalization

We compute QC metrics for each cell and identify cells with low library sizes, low numbers of expressed genes, or high ERCC content.


```r
sce.gse85241 <- calculateQCMetrics(sce.gse85241, compact=TRUE)
QC <- sce.gse85241$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

```
##   LowLib LowNgenes HighSpike
## 1    577       669       696
```

Low-quality cells are defined as those with extreme values for these QC metrics and are removed.


```r
discard <- low.lib | low.genes | high.spike
sce.gse85241 <- sce.gse85241[,!discard]
summary(discard)
```

```
##    Mode   FALSE    TRUE 
## logical    2346     726
```

We compute size factors for the endogenous genes and spike-in transcripts, and use them to compute log-normalized expression values.


```r
set.seed(1000)
clusters <- quickCluster(sce.gse85241, min.mean=0.1, method="igraph")
table(clusters)
```

```
## clusters
##   1   2   3   4 
## 366 829 536 615
```

```r
sce.gse85241 <- computeSumFactors(sce.gse85241, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse85241))
```

```
##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
##  0.07818  0.54252  0.82828  1.00000  1.21809 13.98107
```

```r
sce.gse85241 <- computeSpikeFactors(sce.gse85241, general.use=FALSE)
summary(sizeFactors(sce.gse85241, "ERCC"))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.09295 0.61309 0.88902 1.00000 1.27519 4.04643
```

```r
sce.gse85241 <- normalize(sce.gse85241)
```

### Identifying highly variable genes

We fit a trend to the spike-in variances as previously described, allowing us to model the technical noise for each gene (Figure \@ref(fig:var-gse85241)).
Again, we set `block=` to ensure that uninteresting differences between plates or donors do not inflate the variance.


```r
block <- paste0(sce.gse85241$Plate, "_", sce.gse85241$Donor)
fit <- trendVar(sce.gse85241, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse85241, fit)
plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse85241)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/var-gse85241-1.png" alt="Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)." width="100%" />
<p class="caption">(\#fig:var-gse85241)Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).</p>
</div>

We order genes by decreasing biological component, as described above.


```r
dec.gse85241 <- dec
dec.gse85241$Symbol <- rowData(sce.gse85241)$Symbol
dec.gse85241 <- dec.gse85241[order(dec.gse85241$bio, decreasing=TRUE),]
head(dec.gse85241)
```

```
## DataFrame with 6 rows and 7 columns
##                             mean            total              bio
##                        <numeric>        <numeric>        <numeric>
## ENSG00000115263 7.66117795271028 6.58012478992514 6.55130339927214
## ENSG00000089199 4.61809000058337 6.40992788330565 6.28816208093923
## ENSG00000169903 3.01191660680515 6.53367263460122 6.17912104404715
## ENSG00000254647 2.00118894223534   6.433634878736 5.87728584991513
## ENSG00000118271 7.33395178329683  5.7334472084949  5.7019866958609
## ENSG00000171951  4.1870092285275 5.56059287063942  5.3958763879724
##                               tech   p.value       FDR      Symbol
##                          <numeric> <numeric> <numeric> <character>
## ENSG00000115263 0.0288213906530016         0         0         GCG
## ENSG00000089199   0.12176580236642         0         0        CHGB
## ENSG00000169903  0.354551590554061         0         0      TM4SF4
## ENSG00000254647  0.556349028820874         0         0         INS
## ENSG00000118271 0.0314605126340036         0         0         TTR
## ENSG00000171951  0.164716482667011         0         0        SCG2
```



## Comments on additional batches

In @haghverdi2018batch, we originally performed batch correction across four separate pancreas scRNA-seq datasets.
For simplicity, we will only consider the two batches generated using CEL-seq(2) and ignore those generated using Smart-seq2 [@segerstolpe2016singlecell;@lawlor2017singlecell].
As one might expect, batch correction is easiest when dealing with data generated from the same technology,
as fewer systematic differences are present that can interfere with the biological structure.
Nonetheless, it is often possible to obtain good results when applying MNN correction to batches of data generated with different technologies.

It is also worth pointing out that both of the CEL-seq(2) batches above contain cells from multiple donors.
Each donor could be treated as a separate batch in their own right, 
reflecting (presumably uninteresting) biological differences between donors due to genotype, age, sex or other factors that are not easily controlled when dealing with humans.
For simplicity, we will ignore the donor effects within each study and only consider the removal of the batch effect between the two studies.
However, we note that it is possible to apply the MNN correction between donors in each batch and then between the batches - see `?fastMNN` for details.

# Feature selection across batches

To obtain a single set of features for batch correction, we compute the average biological component across all batches.
We then take all genes with positive biological components to ensure that all interesting biology is retained, equivalent to the behaviour of `denoisePCA()`.
However, the quality of the correction can often be sensitive to technical noise, which means that some discretion may be required during feature selection.
Users may prefer to take the top 1000-5000 genes with the largest average components, or to use `combineVar()` to obtain combined _p_-values for gene selection.


```r
universe <- intersect(rownames(dec.gse85241), rownames(dec.gse81076))
mean.bio <- (dec.gse85241[universe,"bio"] + dec.gse81076[universe,"bio"])/2
chosen <- universe[mean.bio > 0]
length(chosen)
```

```
## [1] 14642
```

We also rescale each batch to adjust for differences in sequencing depth between batches.
The `multiBatchNorm()` function recomputes log-normalized expression values after adjusting the size factors for systematic differences in coverage between `SingleCellExperiment` objects.
(Keep in mind that the previously computed size factors only remove biases between cells _within_ a single batch.)
This improves the quality of the correction by removing one aspect of the technical differences between batches.


```r
rescaled <- multiBatchNorm(sce.gse85241[universe,], sce.gse81076[universe,])
rescaled.gse85241 <- rescaled[[1]]
rescaled.gse81076 <- rescaled[[2]]
```

**Comments from Aaron:**

- Technically, we should have performed variance modelling and feature selection _after_ calling `multiBatchNorm()`.
This ensures that the variance components are estimated from the same values to be used in the batch correction.
In practice, this makes little difference, and it tends to be easier to process each batch separately and consolidate all results in one step as shown above.

# Performing MNN-based correction

Consider a cell $a$ in batch $A$, and identify the cells in batch $B$ that are nearest neighbours to $a$ in the expression space defined by the selected features.
Repeat this for a cell $b$ in batch $B$, identifying its nearest neighbours in $A$.
Mutual nearest neighbours are pairs of cells from different batches that belong in each other's set of nearest neighbours.
The reasoning is that MNN pairs represent cells from the same biological state prior to the application of a batch effect - see @haghverdi2018batch for full theoretical details.
Thus, the difference between cells in MNN pairs can be used as an estimate of the batch effect, the subtraction of which can yield batch-corrected values.

We apply the `fastMNN()` function to the three batches to remove the batch effect, using the genes in `chosen`.
To reduce computational work and technical noise, all cells in all cells are projected into the low-dimensional space defined by the top `d` principal components.
Identification of MNNs and calculation of correction vectors are then performed in this low-dimensional space.
The function returns a matrix of corrected values for downstream analyses like clustering or visualization.


```r
set.seed(100) 
original <- list(
    GSE81076=logcounts(rescaled.gse81076)[chosen,],
    GSE85241=logcounts(rescaled.gse85241)[chosen,]
)

# Slightly convoluted call to avoid re-writing code later.
# Equivalent to fastMNN(GSE81076, GSE85241, k=20, d=50, approximate=TRUE)
mnn.out <- do.call(fastMNN, c(original, list(k=20, d=50, approximate=TRUE)))
dim(mnn.out$corrected)
```

```
## [1] 3637   50
```

Each row of the `corrected` matrix corresponds to a cell in one of the batches.
The `batch` field contains a run-length encoding object specifying the batch of origin of each row.


```r
mnn.out$batch
```

```
## character-Rle of length 3637 with 2 runs
##   Lengths:       1291       2346
##   Values : "GSE81076" "GSE85241"
```

Advanced users may also be interested in the list of `DataFrame`s in the `pairs` field.
Each `DataFrame` describes the MNN pairs identified upon merging of each successive batch.
This may be useful for checking the identified MNN pairs against known cell type identity, e.g., to determine if the cell types are being paired correctly.


```r
mnn.out$pairs
```

```
## [[1]]
## DataFrame with 6628 rows and 2 columns
##          first    second
##      <integer> <integer>
## 1            1      1793
## 2            1      2086
## 3           15      1611
## 4           15      2511
## 5           15      2574
## ...        ...       ...
## 6624      1289      1537
## 6625      1289      2624
## 6626      1289      2338
## 6627      1289      2793
## 6628      1289      2000
```

As previously mentioned, we have only used two batches here to simplify the workflow.
However, the MNN approach is not limited to two batches, and inclusion of more batches is as simple as adding more `SingleCellExperiment` objects to the `fastMNN()` call.

**Comments from Aaron:**

- The `k=` parameter specifies the number of nearest neighbours to consider when defining MNN pairs.
This should be interpreted as the minimum frequency of each cell type or state in each batch.
Larger values will improve the precision of the correction by increasing the number of MNN pairs, 
at the cost of reducing accuracy by allowing MNN pairs to form between cells of different type.
- The order of the supplied batches does matter, as all batches are corrected towards the first.
We suggest setting the largest and/or most heterogeneous batch as the first.
This ensures that sufficient MNN pairs will be identified between the first and other batches for stable correction.
In situations where the nature of each batch is unknown, users can set `auto.order=TRUE` to allow `fastMNN()` to empirically choose which batches to merge at each step.
Batches are chosen to maximize the number of MNN pairs in order to provide a stable correction.
- When `approximate=TRUE`, `fastMNN()` uses methods from the *[irlba](https://CRAN.R-project.org/package=irlba)* package to perform the principal components analysis quickly.
While the run-to-run differences should be minimal, it does mean that `set.seed()` is required to obtain fully reproducible results.

# Examining the effect of correction

We create a new `SingleCellExperiment` object containing log-expression values for all cells, along with information regarding the batch of origin.
The MNN-corrected values are stored as dimensionality reduction results, befitting the principal components analysis performed within `fastMNN()`. 


```r
omat <- do.call(cbind, original)
sce <- SingleCellExperiment(list(logcounts=omat))
reducedDim(sce, "MNN") <- mnn.out$corrected
sce$Batch <- as.character(mnn.out$batch)
sce
```

```
## class: SingleCellExperiment 
## dim: 14642 3637 
## metadata(0):
## assays(1): logcounts
## rownames(14642): ENSG00000115263 ENSG00000089199 ... ENSG00000125445
##   ENSG00000176731
## rowData names(0):
## colnames(3637): D2ex_1 D2ex_2 ... D30.8_93 D30.8_94
## colData names(1): Batch
## reducedDimNames(1): MNN
## spikeNames(0):
```

We examine the batch correction with some _t_-SNE plots.
Figure~\@ref(fig:tsne-batch) demonstrates how the cells separate by batch of origin in the uncorrected data.
After correction, more intermingling between batches is observed, consistent with the removal of batch effects.
Note that the E-MTAB-5601 dataset still displays some separation, which is probably due to the fact that the other batches are UMI datasets.


```r
set.seed(100)
# Using irlba to set up the t-SNE, for speed.
osce <- runPCA(sce, ntop=Inf, method="irlba")
osce <- runTSNE(osce, use_dimred="PCA")
ot <- plotTSNE(osce, colour_by="Batch") + ggtitle("Original")

set.seed(100)
csce <- runTSNE(sce, use_dimred="MNN")
ct <- plotTSNE(csce, colour_by="Batch") + ggtitle("Corrected")

multiplot(ot, ct, cols=2)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/tsne-batch-1.png" alt="t-SNE plots of the pancreas datasets, before and after MNN correction. Each point represents a cell and is coloured by the batch of origin." width="960" />
<p class="caption">(\#fig:tsne-batch)t-SNE plots of the pancreas datasets, before and after MNN correction. Each point represents a cell and is coloured by the batch of origin.</p>
</div>

We colour by the expression of marker genes for known pancreas cell types to determine whether the correction is biologically sensible.
Cells in the same visual cluster express the same marker genes (Figure \@ref(fig:tsne-markers)), indicating that the correction maintains separation of cell types.


```r
ct.gcg <- plotTSNE(csce, colour_by="ENSG00000115263") + 
    ggtitle("Alpha cells (GCG)")
ct.ins <- plotTSNE(csce, colour_by="ENSG00000254647") + 
    ggtitle("Beta cells (INS)")
ct.sst <- plotTSNE(csce, colour_by="ENSG00000157005") + 
    ggtitle("Delta cells (SST)")
ct.ppy <- plotTSNE(csce, colour_by="ENSG00000108849") + 
    ggtitle("PP cells (PPY)")
multiplot(ct.gcg, ct.ins, ct.sst, ct.ppy, cols=2)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/tsne-markers-1.png" alt="t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of key marker genes for known cell types in the pancreas." width="960" />
<p class="caption">(\#fig:tsne-markers)t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of key marker genes for known cell types in the pancreas.</p>
</div>

# Using the corrected values in downstream analyses

For downstream analyses, the MNN-corrected values can be treated in the same manner as any other dimensionality reduction result.
For example, it is straightforward to use the MNN-corrected values directly used for clustering analyses, as shown below.


```r
snn.gr <- buildSNNGraph(sce, use.dimred="MNN")
clusters <- igraph::cluster_walktrap(snn.gr)
table(clusters$membership, sce$Batch)
```

```
##     
##      GSE81076 GSE85241
##   1        71        0
##   2       213      483
##   3       321      283
##   4       344      258
##   5       217      848
##   6        63      197
##   7        25      108
##   8        22      126
##   9         0       18
##   10        8        4
##   11        7       21
```

Figure \@ref(fig:tsne-cluster) shows strong correspondence between the cluster labels and separation in _t_-SNE space.


```r
csce$Cluster <- factor(clusters$membership)
plotTSNE(csce, colour_by="Cluster")
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/tsne-cluster-1.png" alt="t-SNE plot after MMN correction, where each point represents a cell and is coloured by its cluster identity." width="100%" />
<p class="caption">(\#fig:tsne-cluster)t-SNE plot after MMN correction, where each point represents a cell and is coloured by its cluster identity.</p>
</div>

Differential expression analyses should be performed on the **original** log-expression values or counts.
We do not use the corrected values here (which no longer correspond to genes anyway) except to obtain the clusters or trajectories to be characterized.
To model the batch effect, we set the batch of origin as the `block=` argument in `findMarkers()`.
This will perform all comparisons between clusters _within_ each batch, and then combine the _p_-values with Stouffer's Z method to consolidate results across batches.
Intra-batch comparisons are robust to differences between batches but assume that each pair of clusters is present in at least one batch.


```r
m.out <- findMarkers(sce, clusters$membership, block=sce$Batch,
    direction="up")        
demo <- m.out[["5"]] # looking at cluster 5 (probably alpha cells).
demo <- demo[demo$Top <= 3,]

library(org.Hs.eg.db)
data.frame(row.names=rownames(demo),
    Symbol=mapIds(org.Hs.eg.db, keytype="ENSEMBL", 
        keys=rownames(demo), column="SYMBOL"),
    Top=demo$Top, FDR=demo$FDR)
```

```
##                  Symbol Top           FDR
## ENSG00000170561    IRX2   1  0.000000e+00
## ENSG00000169903  TM4SF4   1  0.000000e+00
## ENSG00000007372    PAX6   1 1.188930e-278
## ENSG00000078098     FAP   1 6.943194e-271
## ENSG00000135447 PPP1R1A   1 7.924989e-267
## ENSG00000171951    SCG2   1 2.210830e-264
## ENSG00000018236   CNTN1   1 3.494569e-249
## ENSG00000115263     GCG   2  0.000000e+00
## ENSG00000011347    SYT7   2  0.000000e+00
## ENSG00000109472     CPE   2 2.735566e-315
## ENSG00000166922    SCG5   2 4.455261e-278
## ENSG00000145730     PAM   2 3.422295e-219
## ENSG00000155093  PTPRN2   2 6.776902e-217
## ENSG00000138131   LOXL4   2 2.933115e-179
## ENSG00000145321      GC   3  0.000000e+00
## ENSG00000054356   PTPRN   3 4.292725e-309
## ENSG00000089199    CHGB   3 2.822294e-291
## ENSG00000163499  CRYBA2   3 1.703102e-285
## ENSG00000004848     ARX   3 2.658646e-249
## ENSG00000174938  SEZ6L2   3 1.818052e-234
## ENSG00000076554   TPD52   3 9.931431e-184
## ENSG00000138193   PLCE1   3 9.923787e-132
```



Another approach is to define a design matrix containing the batch of origin as the sole factor.
`findMarkers()` will then fit a linear model to the log-expression values, similar to the use of *[limma](https://bioconductor.org/packages/3.8/limma)* for bulk RNA sequencing data [@ritchie2015limma].
This handles situations where multiple batches contain unique clusters, whereby comparisons can be implicitly performed between shared cell types.
However, the use of a linear model makes some strong assumptions about the homogeneity of the batch effect across cell types and the equality of variances.


```r
design <- model.matrix(~sce$Batch)
m.alt <- findMarkers(sce, clusters$membership, design=design, 
    direction="up")
demo <- m.alt[["5"]]
demo <- demo[demo$Top <= 3,]

data.frame(row.names=rownames(demo),
    Symbol=mapIds(org.Hs.eg.db, keytype="ENSEMBL", 
        keys=rownames(demo), column="SYMBOL"),
    Top=demo$Top, FDR=demo$FDR)
```

```
##                 Symbol Top           FDR
## ENSG00000118271    TTR   1 1.221128e-119
## ENSG00000166922   SCG5   1 1.243849e-105
## ENSG00000115263    GCG   1 3.735214e-100
## ENSG00000109472    CPE   2  5.811790e-96
## ENSG00000125851  PCSK2   2  4.179052e-94
## ENSG00000169903 TM4SF4   2  1.476173e-72
## ENSG00000204103   MAFB   2  1.441558e-44
## ENSG00000089199   CHGB   3  7.781188e-99
## ENSG00000145321     GC   3  7.237113e-53
## ENSG00000170561   IRX2   3  1.069073e-31
```

It is similarly possible to perform these analyses with standard Bioconductor packages for DE analysis such as *[edgeR](https://bioconductor.org/packages/3.8/edgeR)* or *[limma](https://bioconductor.org/packages/3.8/limma)*.
Note that the use of `block=` is roughly similar to the use of a batch-cluster interaction model and testing whether the average log-fold change across batches is equal to zero.

**Comments from Aaron:**

- Users of the older `mnnCorrect()` function will note that the function returned corrected _expression_ values.
Thus, it is tempting to use these corrected values directly for DE analyses.
This is inappropriate for various reasons:
    - The default parameters of `mnnCorrect()` do not return corrected values on the log-scale, but rather a cosine-normalized log-scale.
      This makes it difficult to interpret the effect size of DE analyses based on the corrected values.
    - It is usually inappropriate to perform DE analyses on batch-corrected values, due to the failure to model the uncertainty of the correction.
      This usually results in loss of type I error control, i.e., more false positives than expected.
    - The correction does _not_ preserve the mean-variance relationship.

# Concluding remarks

All software packages used in this workflow are publicly available from the Comprehensive R Archive Network (https://cran.r-project.org) or the Bioconductor project (http://bioconductor.org).
The specific version numbers of the packages used are shown below, along with the version of the R installation.


```r
sessionInfo()
```

```
## R version 3.5.0 Patched (2018-04-30 r74679)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.5 LTS
## 
## Matrix products: default
## BLAS: /home/cri.camres.org/lun01/Software/R/R-3-5-branch/lib/libRblas.so
## LAPACK: /home/cri.camres.org/lun01/Software/R/R-3-5-branch/lib/libRlapack.so
## 
## locale:
##  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
##  [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
##  [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] scran_1.9.20                scater_1.9.20              
##  [3] ggplot2_3.0.0               SingleCellExperiment_1.3.10
##  [5] SummarizedExperiment_1.11.6 DelayedArray_0.7.37        
##  [7] BiocParallel_1.15.11        matrixStats_0.54.0         
##  [9] GenomicRanges_1.33.13       GenomeInfoDb_1.17.1        
## [11] org.Hs.eg.db_3.6.0          AnnotationDbi_1.43.1       
## [13] IRanges_2.15.17             S4Vectors_0.19.19          
## [15] Biobase_2.41.2              BiocGenerics_0.27.1        
## [17] bindrcpp_0.2.2              BiocFileCache_1.5.5        
## [19] dbplyr_1.2.2                knitr_1.20                 
## [21] BiocStyle_2.9.6            
## 
## loaded via a namespace (and not attached):
##  [1] dynamicTreeCut_1.63-1    viridis_0.5.1           
##  [3] httr_1.3.1               edgeR_3.23.3            
##  [5] bit64_0.9-7              viridisLite_0.3.0       
##  [7] DelayedMatrixStats_1.3.8 assertthat_0.2.0        
##  [9] statmod_1.4.30           highr_0.7               
## [11] BiocManager_1.30.2       blob_1.1.1              
## [13] vipor_0.4.5              GenomeInfoDbData_1.1.0  
## [15] yaml_2.2.0               pillar_1.3.0            
## [17] RSQLite_2.1.1            backports_1.1.2         
## [19] lattice_0.20-35          limma_3.37.4            
## [21] glue_1.3.0               digest_0.6.16           
## [23] XVector_0.21.3           colorspace_1.3-2        
## [25] cowplot_0.9.3            htmltools_0.3.6         
## [27] Matrix_1.2-14            plyr_1.8.4              
## [29] pkgconfig_2.0.2          bookdown_0.7            
## [31] zlibbioc_1.27.0          purrr_0.2.5             
## [33] scales_1.0.0             HDF5Array_1.9.15        
## [35] Rtsne_0.13               kmknn_0.99.16           
## [37] tibble_1.4.2             withr_2.1.2             
## [39] lazyeval_0.2.1           magrittr_1.5            
## [41] crayon_1.3.4             memoise_1.1.0           
## [43] evaluate_0.11            beeswarm_0.2.3          
## [45] tools_3.5.0              stringr_1.3.1           
## [47] Rhdf5lib_1.3.3           locfit_1.5-9.1          
## [49] munsell_0.5.0            irlba_2.3.2             
## [51] compiler_3.5.0           rlang_0.2.2             
## [53] rhdf5_2.25.9             grid_3.5.0              
## [55] RCurl_1.95-4.11          rappdirs_0.3.1          
## [57] igraph_1.2.2             labeling_0.3            
## [59] bitops_1.0-6             rmarkdown_1.10          
## [61] gtable_0.2.0             DBI_1.0.0               
## [63] reshape2_1.4.3           R6_2.2.2                
## [65] gridExtra_2.3            dplyr_0.7.6             
## [67] bit_1.1-14               bindr_0.1.1             
## [69] rprojroot_1.3-2          stringi_1.2.4           
## [71] ggbeeswarm_0.6.0         Rcpp_0.12.18            
## [73] tidyselect_0.2.4         xfun_0.3
```

# References

